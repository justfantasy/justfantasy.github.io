{"title":"Java并发编程实战","author":"王宝令","cover":"https://static001.geekbang.org/resource/image/46/6f/469a11fbb1fd91cbbec83bd663dc376f.jpg","cid":159,"list":[{"id":83087,"title":"开篇词 | 你为什么需要学习并发编程？","chapter":"630"},{"id":83267,"title":"学习攻略 | 如何才能学好并发编程？","chapter":"631"},{"id":83682,"title":"01 | 可见性、原子性和有序性问题：并发编程Bug的源头","chapter":"632"},{"id":84017,"title":"02 | Java内存模型：看Java如何解决可见性和有序性问题","chapter":"632"},{"id":84344,"title":"03 | 互斥锁（上）：解决原子性问题","chapter":"632"},{"id":84601,"title":"04 | 互斥锁（下）：如何用一把锁保护多个资源？","chapter":"632"},{"id":85001,"title":"05 | 一不小心就死锁了，怎么办？","chapter":"632"},{"id":85241,"title":"06 | 用“等待-通知”机制优化循环等待","chapter":"632"},{"id":85702,"title":"07 | 安全性、活跃性以及性能问题","chapter":"632"},{"id":86089,"title":"08 | 管程：并发编程的万能钥匙","chapter":"632"},{"id":86366,"title":"09 | Java线程（上）：Java线程的生命周期","chapter":"632"},{"id":86666,"title":"10 | Java线程（中）：创建多少线程才是合适的？","chapter":"632"},{"id":86695,"title":"11 | Java线程（下）：为什么局部变量是线程安全的？","chapter":"632"},{"id":87365,"title":"12 | 如何用面向对象思想写好并发程序？","chapter":"632"},{"id":87749,"title":"13 | 理论基础模块热点问题答疑","chapter":"632"},{"id":87779,"title":"14 | Lock和Condition（上）：隐藏在并发包中的管程","chapter":"633"},{"id":88487,"title":"15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？","chapter":"633"},{"id":88499,"title":"16 | Semaphore：如何快速实现一个限流器？","chapter":"633"},{"id":88909,"title":"17 | ReadWriteLock：如何快速实现一个完备的缓存？","chapter":"633"},{"id":89456,"title":"18 | StampedLock：有没有比读写锁更快的锁？","chapter":"633"},{"id":89461,"title":"19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？","chapter":"633"},{"id":90201,"title":"20 | 并发容器：都有哪些“坑”需要我们填？","chapter":"633"},{"id":90515,"title":"21 | 原子类：无锁工具类的典范","chapter":"633"},{"id":90771,"title":"22 | Executor与线程池：如何创建正确的线程池？","chapter":"633"},{"id":91292,"title":"23 | Future：如何用多线程实现最优的“烧水泡茶”程序？","chapter":"633"},{"id":91569,"title":"24 | CompletableFuture：异步编程没那么难","chapter":"633"},{"id":92245,"title":"25 | CompletionService：如何批量执行异步任务？","chapter":"633"},{"id":92524,"title":"26 | Fork/Join：单机版的MapReduce","chapter":"633"},{"id":92849,"title":"27 | 并发工具类模块热点问题答疑","chapter":"633"},{"id":92856,"title":"28 | Immutability模式：如何利用不变性解决并发问题？","chapter":"634"},{"id":93154,"title":"29 | Copy-on-Write模式：不是延时策略的COW","chapter":"634"},{"id":93745,"title":"30 | 线程本地存储模式：没有共享，就没有伤害","chapter":"634"},{"id":94097,"title":"31 | Guarded Suspension模式：等待唤醒机制的规范实现","chapter":"634"},{"id":94604,"title":"32 | Balking模式：再谈线程安全的单例模式","chapter":"634"},{"id":95098,"title":"33 | Thread-Per-Message模式：最简单实用的分工方法","chapter":"634"},{"id":95525,"title":"34 | Worker Thread模式：如何避免重复创建线程？","chapter":"634"},{"id":95847,"title":"35 | 两阶段终止模式：如何优雅地终止线程？","chapter":"634"},{"id":96168,"title":"36 | 生产者-消费者模式：用流水线思想提高效率","chapter":"634"},{"id":96736,"title":"37 | 设计模式模块热点问题答疑","chapter":"634"},{"id":97231,"title":"38 | 案例分析（一）：高性能限流器Guava RateLimiter","chapter":"635"},{"id":97622,"title":"39 | 案例分析（二）：高性能网络应用框架Netty","chapter":"635"},{"id":98134,"title":"40 | 案例分析（三）：高性能队列Disruptor","chapter":"635"},{"id":98491,"title":"41 | 案例分析（四）：高性能数据库连接池HiKariCP","chapter":"635"},{"id":98903,"title":"42 | Actor模型：面向对象原生的并发模型","chapter":"636"},{"id":99251,"title":"43 | 软件事务内存：借鉴数据库的并发经验","chapter":"636"},{"id":99787,"title":"44 | 协程：更轻量级的线程","chapter":"636"},{"id":100098,"title":"45 | CSP模型：Golang的主力队员","chapter":"636"},{"id":100627,"title":"结束语 | 十年之后，初心依旧","chapter":"678"},{"id":243424,"title":"结课测试 | 这些Java并发编程实战的知识你都掌握了吗？","chapter":"678"},{"id":102300,"title":"用户来信 | 真好，面试考到这些并发编程，我都答对了！","chapter":"688"},{"id":105074,"title":"3 个用户来信 | 打开一个新的并发世界","chapter":"688"},{"id":83087,"title":"开篇词 | 你为什么需要学习并发编程？","chapter":"630"},{"id":83267,"title":"学习攻略 | 如何才能学好并发编程？","chapter":"631"},{"id":83682,"title":"01 | 可见性、原子性和有序性问题：并发编程Bug的源头","chapter":"632"},{"id":84017,"title":"02 | Java内存模型：看Java如何解决可见性和有序性问题","chapter":"632"},{"id":84344,"title":"03 | 互斥锁（上）：解决原子性问题","chapter":"632"},{"id":84601,"title":"04 | 互斥锁（下）：如何用一把锁保护多个资源？","chapter":"632"},{"id":85001,"title":"05 | 一不小心就死锁了，怎么办？","chapter":"632"},{"id":85241,"title":"06 | 用“等待-通知”机制优化循环等待","chapter":"632"},{"id":85702,"title":"07 | 安全性、活跃性以及性能问题","chapter":"632"},{"id":86089,"title":"08 | 管程：并发编程的万能钥匙","chapter":"632"},{"id":86366,"title":"09 | Java线程（上）：Java线程的生命周期","chapter":"632"},{"id":86666,"title":"10 | Java线程（中）：创建多少线程才是合适的？","chapter":"632"},{"id":86695,"title":"11 | Java线程（下）：为什么局部变量是线程安全的？","chapter":"632"},{"id":87365,"title":"12 | 如何用面向对象思想写好并发程序？","chapter":"632"},{"id":87749,"title":"13 | 理论基础模块热点问题答疑","chapter":"632"},{"id":87779,"title":"14 | Lock和Condition（上）：隐藏在并发包中的管程","chapter":"633"},{"id":88487,"title":"15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？","chapter":"633"},{"id":88499,"title":"16 | Semaphore：如何快速实现一个限流器？","chapter":"633"},{"id":88909,"title":"17 | ReadWriteLock：如何快速实现一个完备的缓存？","chapter":"633"},{"id":89456,"title":"18 | StampedLock：有没有比读写锁更快的锁？","chapter":"633"},{"id":89461,"title":"19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？","chapter":"633"},{"id":90201,"title":"20 | 并发容器：都有哪些“坑”需要我们填？","chapter":"633"},{"id":90515,"title":"21 | 原子类：无锁工具类的典范","chapter":"633"},{"id":90771,"title":"22 | Executor与线程池：如何创建正确的线程池？","chapter":"633"},{"id":91292,"title":"23 | Future：如何用多线程实现最优的“烧水泡茶”程序？","chapter":"633"},{"id":91569,"title":"24 | CompletableFuture：异步编程没那么难","chapter":"633"},{"id":92245,"title":"25 | CompletionService：如何批量执行异步任务？","chapter":"633"},{"id":92524,"title":"26 | Fork/Join：单机版的MapReduce","chapter":"633"},{"id":92849,"title":"27 | 并发工具类模块热点问题答疑","chapter":"633"},{"id":92856,"title":"28 | Immutability模式：如何利用不变性解决并发问题？","chapter":"634"},{"id":93154,"title":"29 | Copy-on-Write模式：不是延时策略的COW","chapter":"634"},{"id":93745,"title":"30 | 线程本地存储模式：没有共享，就没有伤害","chapter":"634"},{"id":94097,"title":"31 | Guarded Suspension模式：等待唤醒机制的规范实现","chapter":"634"},{"id":94604,"title":"32 | Balking模式：再谈线程安全的单例模式","chapter":"634"},{"id":95098,"title":"33 | Thread-Per-Message模式：最简单实用的分工方法","chapter":"634"},{"id":95525,"title":"34 | Worker Thread模式：如何避免重复创建线程？","chapter":"634"},{"id":95847,"title":"35 | 两阶段终止模式：如何优雅地终止线程？","chapter":"634"},{"id":96168,"title":"36 | 生产者-消费者模式：用流水线思想提高效率","chapter":"634"},{"id":96736,"title":"37 | 设计模式模块热点问题答疑","chapter":"634"},{"id":97231,"title":"38 | 案例分析（一）：高性能限流器Guava RateLimiter","chapter":"635"},{"id":97622,"title":"39 | 案例分析（二）：高性能网络应用框架Netty","chapter":"635"},{"id":98134,"title":"40 | 案例分析（三）：高性能队列Disruptor","chapter":"635"},{"id":98491,"title":"41 | 案例分析（四）：高性能数据库连接池HiKariCP","chapter":"635"},{"id":98903,"title":"42 | Actor模型：面向对象原生的并发模型","chapter":"636"},{"id":99251,"title":"43 | 软件事务内存：借鉴数据库的并发经验","chapter":"636"},{"id":99787,"title":"44 | 协程：更轻量级的线程","chapter":"636"},{"id":100098,"title":"45 | CSP模型：Golang的主力队员","chapter":"636"},{"id":100627,"title":"结束语 | 十年之后，初心依旧","chapter":"678"},{"id":243424,"title":"结课测试 | 这些Java并发编程实战的知识你都掌握了吗？","chapter":"678"},{"id":102300,"title":"用户来信 | 真好，面试考到这些并发编程，我都答对了！","chapter":"688"},{"id":105074,"title":"3 个用户来信 | 打开一个新的并发世界","chapter":"688"},{"id":83087,"title":"开篇词 | 你为什么需要学习并发编程？","chapter":"630"},{"id":83267,"title":"学习攻略 | 如何才能学好并发编程？","chapter":"631"},{"id":83682,"title":"01 | 可见性、原子性和有序性问题：并发编程Bug的源头","chapter":"632"},{"id":84017,"title":"02 | Java内存模型：看Java如何解决可见性和有序性问题","chapter":"632"},{"id":84344,"title":"03 | 互斥锁（上）：解决原子性问题","chapter":"632"},{"id":84601,"title":"04 | 互斥锁（下）：如何用一把锁保护多个资源？","chapter":"632"},{"id":85001,"title":"05 | 一不小心就死锁了，怎么办？","chapter":"632"},{"id":85241,"title":"06 | 用“等待-通知”机制优化循环等待","chapter":"632"},{"id":85702,"title":"07 | 安全性、活跃性以及性能问题","chapter":"632"},{"id":86089,"title":"08 | 管程：并发编程的万能钥匙","chapter":"632"},{"id":86366,"title":"09 | Java线程（上）：Java线程的生命周期","chapter":"632"},{"id":86666,"title":"10 | Java线程（中）：创建多少线程才是合适的？","chapter":"632"},{"id":86695,"title":"11 | Java线程（下）：为什么局部变量是线程安全的？","chapter":"632"},{"id":87365,"title":"12 | 如何用面向对象思想写好并发程序？","chapter":"632"},{"id":87749,"title":"13 | 理论基础模块热点问题答疑","chapter":"632"},{"id":87779,"title":"14 | Lock和Condition（上）：隐藏在并发包中的管程","chapter":"633"},{"id":88487,"title":"15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？","chapter":"633"},{"id":88499,"title":"16 | Semaphore：如何快速实现一个限流器？","chapter":"633"},{"id":88909,"title":"17 | ReadWriteLock：如何快速实现一个完备的缓存？","chapter":"633"},{"id":89456,"title":"18 | StampedLock：有没有比读写锁更快的锁？","chapter":"633"},{"id":89461,"title":"19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？","chapter":"633"},{"id":90201,"title":"20 | 并发容器：都有哪些“坑”需要我们填？","chapter":"633"},{"id":90515,"title":"21 | 原子类：无锁工具类的典范","chapter":"633"},{"id":90771,"title":"22 | Executor与线程池：如何创建正确的线程池？","chapter":"633"},{"id":91292,"title":"23 | Future：如何用多线程实现最优的“烧水泡茶”程序？","chapter":"633"},{"id":91569,"title":"24 | CompletableFuture：异步编程没那么难","chapter":"633"},{"id":92245,"title":"25 | CompletionService：如何批量执行异步任务？","chapter":"633"},{"id":92524,"title":"26 | Fork/Join：单机版的MapReduce","chapter":"633"},{"id":92849,"title":"27 | 并发工具类模块热点问题答疑","chapter":"633"},{"id":92856,"title":"28 | Immutability模式：如何利用不变性解决并发问题？","chapter":"634"},{"id":93154,"title":"29 | Copy-on-Write模式：不是延时策略的COW","chapter":"634"},{"id":93745,"title":"30 | 线程本地存储模式：没有共享，就没有伤害","chapter":"634"},{"id":94097,"title":"31 | Guarded Suspension模式：等待唤醒机制的规范实现","chapter":"634"},{"id":94604,"title":"32 | Balking模式：再谈线程安全的单例模式","chapter":"634"},{"id":95098,"title":"33 | Thread-Per-Message模式：最简单实用的分工方法","chapter":"634"},{"id":95525,"title":"34 | Worker Thread模式：如何避免重复创建线程？","chapter":"634"},{"id":95847,"title":"35 | 两阶段终止模式：如何优雅地终止线程？","chapter":"634"},{"id":96168,"title":"36 | 生产者-消费者模式：用流水线思想提高效率","chapter":"634"},{"id":96736,"title":"37 | 设计模式模块热点问题答疑","chapter":"634"},{"id":97231,"title":"38 | 案例分析（一）：高性能限流器Guava RateLimiter","chapter":"635"},{"id":97622,"title":"39 | 案例分析（二）：高性能网络应用框架Netty","chapter":"635"},{"id":98134,"title":"40 | 案例分析（三）：高性能队列Disruptor","chapter":"635"},{"id":98491,"title":"41 | 案例分析（四）：高性能数据库连接池HiKariCP","chapter":"635"},{"id":98903,"title":"42 | Actor模型：面向对象原生的并发模型","chapter":"636"},{"id":99251,"title":"43 | 软件事务内存：借鉴数据库的并发经验","chapter":"636"},{"id":99787,"title":"44 | 协程：更轻量级的线程","chapter":"636"},{"id":100098,"title":"45 | CSP模型：Golang的主力队员","chapter":"636"},{"id":100627,"title":"结束语 | 十年之后，初心依旧","chapter":"678"},{"id":243424,"title":"结课测试 | 这些Java并发编程实战的知识你都掌握了吗？","chapter":"678"},{"id":102300,"title":"用户来信 | 真好，面试考到这些并发编程，我都答对了！","chapter":"688"},{"id":105074,"title":"3 个用户来信 | 打开一个新的并发世界","chapter":"688"}]}